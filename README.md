# Emerging-Sys-Arch
Artifact 1: "pwmled2.c" was designed to control the PWM signals for two LEDs on a TI board. The problem it solved was creating a program to change the duty cycles of two LEDs in a repeating pattern, achieving different brightness levels for these LEDs. It was essentially a hardware control application.

Artifact 2: "uart2echo.c" was developed to echo characters received over UART and control an LED on a Launchpad Board based on user input. This application addressed the need to interact with a user through a UART interface and control an LED accordingly, making it a combination of hardware and user interaction.

What I did particularly well:
1. Code Explanation: I provided detailed explanations of the code and answered specific questions related to each code artifact.
2. Code Analysis: I analyzed the purpose of each code section and highlighted key functions and variables.

Where I could improve:
1. In the reflection, I could provide more insights into the challenges faced during the project and how I overcame them.
2. Providing examples of specific business requirements and how emerging systems architectures and technologies can meet those requirements would enhance the recommendation section.

Tools and resources added to the support network:
I improved my understanding of embedded systems by working with TI's Code Composer Studio and their provided drivers. In future projects, I can leverage this experience and the knowledge gained from working with hardware-specific code.

Transferable skills:
1. Hardware Interaction: Experience with embedded systems and hardware control will be transferable to other projects involving IoT, robotics, or any application that interfaces with physical devices.
2. Code Analysis: The ability to understand and analyze existing code is valuable in software development, especially when dealing with complex systems.
3. Troubleshooting: I developed problem-solving skills, particularly in debugging hardware-related issues, which will be useful in similar projects.

Maintainability, readability, and adaptability:
1. Code Comments: Both artifacts include comments that explain the purpose of code sections and variables, making it easier for others to understand and modify the code.
2. Modularity: Code in both artifacts is divided into functions and structured in a way that allows for future modifications or additions.
3. Parameterization: Key parameters, such as the PWM period in Artifact 1 and UART baud rate in Artifact 2, are defined as variables, making it easy to adapt the code for different hardware or requirements.
4. Error Handling: Both artifacts include error handling to ensure robustness and stability in the face of unexpected issues.
